Next steps
==========

- on doit toujours retourner un SubstitutionBag, meme si l'operation tryMatch n'a pas reussi
-- SubstitutionBag doit contenir un flag success
-- substitution bag peut être nettoyé
-- on n'a plus besoin de linkedhashed, un hashset seul doit suffir.

- unifcation à l'envers
- tests avec http://en.wikipedia.org/wiki/Unification_%28computing%29

- ajouter les préconditions aux axiomes
-- c'est un term de codomain boolean

- réécrire getvariables
- renommer substitution en unification

- adt ne peut avoir qu'une seule constante du même nom
- idem pour variable
- tester occurscheck dans SubstitutionBag

- ajouter les axiomes
-- and(x, false) = false
-- or(x, true) = true
-- est-ce que and(x, false) fait un shortcut (i.e. pas de réécriture) sur l'évalution de x?
--- je crois que oui
-- cela implique d'avoir une operation qui fait seuleemnt le equals et non le rewrite pour savoir si x != false

Notes
=====

Adt
------
- enlever les singletons sur les adts...
- ajouter une interface/... AdtFactory
- modifier les equals et hashcode pour regarder ce qui se passe quand il y a plusieurs adt
- modéliser le réseau
- equals peut etre supprime de la majorite des termes si on ne peut pas en creer en dehors du package.


Autres
------

- systeme de reecriture
-- ajouter la fonction d'ordre sur les termes
-- knuth-bendix completion => je ne crois pas que c'est necessaire. on va faire la supposition que les systemes passes sont "complets"

- réseau de petri alégbrique
- valider le comportement du réseau avec le black token

Idees
-----

//expectingValue = s(s(s(0)))
//term = add(x,y)

/* axioms:
- add(x, 0) = 0
- add(s(x),y) = s(add(x,y))
*/

Adt.solves(Term term, Term expectingValue) {
SubstitutionBag substitutions = new SubstitutionBag();
boolean existsMatch = term.TryMatchSubstitution(expectingValue);
if (existsMatch) {
}
else {
// righTerm <=> s(add(x,y))
Term rightTerm = this.getAxiom(term).getRightTerm();
if (rightTerm != null)
{
if (rightTerm.tryMatchSubsittution(rightTerm, substitutions)) {
// we found x & >
}
else {
Adt.solves(rightTerm, expectingValue)
}
}
else {
exception nothing to do because the term is not a known operation
}
}
}

s