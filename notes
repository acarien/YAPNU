Next steps
==========

- term rewritter: exception quand aucun adt ne correspond au sort d'un term

- ajouter les préconditions aux axiomes
-- c'est un term de codomain boolean

- adt.getAxiom => termRewritter

- on doit toujours retourner un SubstitutionBag, meme si l'operation tryMatch n'a pas reussi
-- SubstitutionBag doit contenir un flag success

- on peut faire un set de substitutionset qui contienne une contrainte (sous forme de substitutionSet) qui filtre

- unifcation à l'envers
- tests avec http://en.wikipedia.org/wiki/Unification_%28computing%29

- réécrire getvariables
- renommer substitution en unification

- adt ne peut avoir qu'une seule constante du même nom
- idem pour variable
- tester occurscheck dans SubstitutionBag

- verifier tout les usages de getVariables() (=> créer un hasVariable?)

- ajouter les axiomes
-- and(x, false) = false
-- or(x, true) = true
-- est-ce que and(x, false) fait un shortcut (i.e. pas de réécriture) sur l'évalution de x?
--- je crois que oui
-- cela implique d'avoir une operation qui fait seuleemnt le equals et non le rewrite pour savoir si x != false

- problème de dépendence de namespace circulaire

Notes
=====

Adt
------
- enlever les singletons sur les adts...
- ajouter une interface/... AdtFactory
- modifier les equals et hashcode pour regarder ce qui se passe quand il y a plusieurs adt
- modéliser le réseau
- equals peut etre supprime de la majorite des termes si on ne peut pas en creer en dehors du package.


Autres
------

- systeme de reecriture
-- ajouter la fonction d'ordre sur les termes
-- knuth-bendix completion => je ne crois pas que c'est necessaire. on va faire la supposition que les systemes passes sont "complets"

- réseau de petri alégbrique
- valider le comportement du réseau avec le black token